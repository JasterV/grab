//! # Main Application Entry Point
//!
//! This module defines the command-line interface (CLI) for `gRab`.
//! It is responsible for:
//!
//! 1. Parsing command-line arguments using `clap`.
//! 2. Validating input files and values.
//! 3. Orchestrating the flow between the CLI input and the internal gRPC client.

mod client;
mod codec;

use crate::client::GrpcClient;
use clap::{Parser, Subcommand};
use std::path::PathBuf;

/// The main command-line argument parser struct.
///
/// This struct holds the top-level configuration and subcommands for the tool.
/// It uses `clap` to derive the parsing logic automatically.
#[derive(Parser)]
#[command(
    name = "grab",
    version,
    about = "gRab: A dynamic gRPC CLI (gRPC + Crab)",
    long_about = "gRab is a Rust-based CLI tool that allows you to make gRPC calls dynamically using JSON."
)]
struct Cli {
    /// The specific command to execute (e.g., `unary`).
    #[command(subcommand)]
    command: Commands,
}

/// The available subcommands for the CLI.
#[derive(Subcommand)]
enum Commands {
    /// Perform a unary gRPC request (a single request followed by a single response).
    ///
    /// This command loads a Protobuf descriptor, connects to a server, sends a JSON payload,
    /// and prints the JSON response.
    Unary {
        /// Path to the binary FileDescriptorSet file (generated by `protoc`).
        /// This file contains the schema definitions for your services.
        #[arg(short, long)]
        descriptor: PathBuf,

        /// The target server address.
        /// Format example: `http://[::1]:50051` or `http://localhost:50051`.
        #[arg(short, long)]
        addr: String,

        /// The fully qualified name of the service to call.
        /// Example: `my.package.MyService`.
        #[arg(short, long)]
        service: String,

        /// The specific method name within the service to invoke.
        /// Example: `CreateUser`.
        #[arg(short, long)]
        method: String,

        /// The request body in JSON format.
        /// This will be dynamically converted to Protobuf based on the schema.
        #[arg(short, long)]
        json: String,

        /// Custom headers to attach to the request.
        /// Format: `key:value`. Can be used multiple times.
        #[arg(short = 'H', long = "header", value_parser = parse_header)]
        headers: Vec<(String, String)>,
    },
}

/// Helper function to parse HTTP headers from the command line.
///
/// Expects a string in the format `"key:value"`.
/// Returns a tuple `(key, value)` or an error message if the format is invalid.
fn parse_header(s: &str) -> Result<(String, String), String> {
    s.split_once(':')
        .map(|(k, v)| (k.trim().to_string(), v.trim().to_string()))
        .ok_or_else(|| "Header format must be 'key:value'".to_string())
}

#[tokio::main]
async fn main() {
    let args = Cli::parse();

    match args.command {
        Commands::Unary {
            descriptor,
            addr,
            service,
            method,
            json,
            headers,
        } => {
            // Validate JSON format immediately before doing expensive operations.
            let json_value: serde_json::Value = match serde_json::from_str(&json) {
                Ok(v) => v,
                Err(e) => {
                    eprintln!("Error: Invalid JSON format");
                    eprintln!("  ╰─> {}", e);
                    std::process::exit(1);
                }
            };

            let file_descriptor_set = match std::fs::read(descriptor) {
                Ok(v) => v,
                Err(e) => {
                    eprintln!("Error: Initialization failed");
                    eprintln!("  ╰─> {}", e);
                    std::process::exit(1);
                }
            };

            let client = match GrpcClient::new(&addr, &file_descriptor_set).await {
                Ok(c) => c,
                Err(e) => {
                    eprintln!("Error: Initialization failed");
                    eprintln!("  ╰─> {}", e);
                    std::process::exit(1);
                }
            };

            println!("Connecting to {}...", addr);
            println!("Calling {}/{}", service, method);

            match client.unary(&service, &method, json_value, headers).await {
                Ok(response_val) => match serde_json::to_string_pretty(&response_val) {
                    Ok(pretty) => println!("{}", pretty),
                    Err(_) => println!("{}", response_val),
                },
                Err(e) => {
                    eprintln!("Error: RPC call failed");
                    eprintln!("  ╰─> {}", e);
                    std::process::exit(2);
                }
            }
        }
    }
}
