//! # Descriptor Registry
//!
//! This module manages the `prost_reflect::DescriptorPool`.
//!
//! The registry can be populated in two ways:
//!
//! 1. **From File**: Loading a binary `.bin` or `.pb` file (usually generated by `protoc`).
//! 2. **From Memory**: Constructed dynamically after fetching schemas via Server Reflection.
use prost_reflect::{DescriptorPool, MethodDescriptor};
use prost_types::FileDescriptorSet;
use std::path::Path;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum DescriptorError {
    #[error("Failed to read descriptor file: {0}")]
    Io(#[from] std::io::Error),
    #[error("Failed to decode descriptor set: {0}")]
    Decode(#[from] prost_reflect::DescriptorError),
    #[error("Service '{0}' not found")]
    ServiceNotFound(String),
    #[error("Method '{0}' not found")]
    MethodNotFound(String),
}

/// A registry that holds loaded Protobuf definitions and allows looking up
/// services and methods by name.
#[derive(Debug)]
pub struct DescriptorRegistry {
    pool: DescriptorPool,
}

impl DescriptorRegistry {
    /// Decodes a FileDescriptorSet directly from a byte slice.
    /// Useful for tests or embedded descriptors.
    #[cfg(test)]
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, DescriptorError> {
        let pool = DescriptorPool::decode(bytes)?;
        Ok(Self { pool })
    }

    /// Creates a registry from a `FileDescriptorSet` (e.g., from Server Reflection).
    pub fn from_file_descriptor_set(set: FileDescriptorSet) -> Result<Self, DescriptorError> {
        let pool = DescriptorPool::from_file_descriptor_set(set)?;
        Ok(Self { pool })
    }

    /// Creates a registry by reading a `.bin` or `.pb` file from disk.    
    pub fn from_file(path: impl AsRef<Path>) -> Result<Self, DescriptorError> {
        let bytes = std::fs::read(path)?;
        let pool = DescriptorPool::decode(bytes.as_slice())?;
        Ok(Self { pool })
    }

    /// Resolves a service and method (e.g., "my.package.MyService", "MyMethod") into a MethodDescriptor.
    pub fn get_method_descriptor(
        &self,
        service_name: &str,
        method_name: &str,
    ) -> Result<MethodDescriptor, DescriptorError> {
        let service = self
            .pool
            .get_service_by_name(service_name)
            .ok_or_else(|| DescriptorError::ServiceNotFound(service_name.to_string()))?;

        service
            .methods()
            .find(|m| m.name() == method_name)
            .ok_or_else(|| DescriptorError::MethodNotFound(method_name.to_string()))
    }
}
